\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename holos.info
@settitle HOLOS: Scientific Simulation and Engineering Framework
@c %**end of header

@copying
HOLOS: Scientific Simulation and Engineering Framework

Copyright (C) 2025 4137314 (holos at mail.com)

This manual is part of HOLOS.

HOLOS is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

HOLOS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HOLOS.  If not, see https://www.gnu.org/licenses/.
@end copying

@titlepage
@title HOLOS: Scientific Simulation and Engineering Framework
@subtitle User and Developer Manual
@author 4137314
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@chapter Introduction

HOLOS is a free, modular, and extensible GNU scientific software platform designed for advanced simulation, physical modeling, and engineering design. Its architecture enables researchers, engineers, and educators to build, analyze, and share complex scientific models with ease.

Key features of HOLOS include:
@itemize @bullet
@item A comprehensive set of libraries for classical and modern physics, engineering, and computational science.
@item Peer-to-peer (P2P) collaboration and distributed computing using GNUnet.
@item Built-in support for artificial intelligence models and scientific machine learning.
@item A command-line interface (CLI) for running simulations, managing models, and automating workflows.
@item Strict adherence to GNU coding standards and free software principles.
@end itemize

HOLOS is written in C for performance and portability, and is intended to foster open, collaborative scientific research and reproducibility.

@menu
* Overview::
* Installation::
* Usage::
* Modules::
* Development::
* License::
@end menu

@node Overview
@chapter Overview

HOLOS provides a unified environment for scientific computing across a broad spectrum of domains:

@itemize @bullet
@item @b{Physics:} Libraries for classical mechanics, quantum mechanics, relativity, thermodynamics, solid-state physics, nuclear physics, astrophysics, electromagnetism, and more.
@item @b{Engineering:} Tools for modeling, simulation, and analysis in various engineering fields.
@item @b{Artificial Intelligence:} Neural network models (MLP, CNN, RNN, GAN, Transformer) for scientific and engineering applications.
@item @b{Peer-to-Peer Collaboration:} Distributed data sharing and computation using GNUnet, enabling collaborative research and open science.
@item @b{Extensibility:} Modular design allows users to add new models, algorithms, and interfaces easily.
@end itemize

The platform is organized into modular libraries and command-line tools, making it suitable for both standalone use and integration into larger workflows. HOLOS aims to bridge the gap between traditional scientific computing and modern collaborative, AI-driven research.

@node Installation
@chapter Installation
To install HOLOS, use the standard GNU procedure:
@example
$ ./configure
$ make
$ make check   # optional: run tests
$ make install
@end example

Dependencies include the GNU Scientific Library (GSL), GNUnet (optional for P2P), and standard C libraries. See the README for details.

@node Usage
@chapter Usage
After installation, you can use the main CLI tool:
@example
$ holos
@end example

You can also link against the HOLOS libraries in your own C programs. Include the relevant headers from @file{include/}.

@node Modules
@chapter Modules

HOLOS is organized into the following main modules:

@menu
* Physics::
* AI::
* P2P::
* CLI::
@end menu

@node Physics

@section Physics
The Physics module is divided into several submodules, each targeting a specific domain of physical science. Each submodule provides specialized headers and functions for simulation and modeling.

@menu
* Classical Mechanics::
* Analytical Mechanics::
* Continuum Mechanics::
* Quantum Mechanics::
* Relativistic Mechanics::
* Astrophysics::
* Electromagnetism::
* Fields::
* Nuclear Physics::
* Solid State Physics::
* Thermodynamics::
@end menu

@node Classical Mechanics
@subsection Classical Mechanics
@file{include/core/phys/mech/classical/}

Provides functions and data structures for Newtonian mechanics, including:
@itemize @bullet
@item @file{dynamics.h} -- Equations of motion, force analysis
@item @file{fluids.h} -- Fluid statics and dynamics
@item @file{kinematics.h} -- Kinematic equations and motion analysis
@item @file{oscillations.h} -- Harmonic and damped oscillators
@item @file{statics.h} -- Static equilibrium and structures
@end itemize

@node dynamics
@subsubsection dynamics.h

The file @code{dynamics.h} defines the Newtonian dynamics API for HOLOS.
It provides data types and functions for simulating particles and rigid bodies
under various forces, with support for integration, diagnostics, and I/O.

@menu
* Dynamics Types::
* Memory Management::
* System Configuration::
* Force Computation::
* Integration::
* Diagnostics::
* Utilities::
@end menu


@node Dynamics Types
@subsubheading Types

@deftp {Data type} dyn_particle_t
Represents a particle with mass, position, velocity, force, charge,
and optional metadata such as @code{id}, @code{tag}, or @code{userdata}.
@end deftp

@deftp {Data type} dyn_system_t
Represents a system of particles, global parameters (e.g. gravitational
constant), integration state, optional constraints, and user-defined data.
@end deftp

@deftp {Enum} dyn_integrator_t
Specifies the integration method:

@table @code
@item DYN_INT_EULER
Euler method.
@item DYN_INT_VERLET
Verlet integrator.
@item DYN_INT_LEAPFROG
Leapfrog integrator.
@item DYN_INT_RK4
Runge–Kutta 4th order.
@item DYN_INT_GSL_ODE
Use GSL ODE solver.
@end table
@end deftp


@node Memory Management
@subsubheading Memory Management

@deftypefun {dyn_system_t *} dyn_system_alloc (size_t N)
Allocate a new system with @var{N} particles.
@end deftypefun

@deftypefun void dyn_system_free (dyn_system_t *sys)
Free a system and all associated memory.
@end deftypefun

@deftypefun void dyn_system_zero_forces (dyn_system_t *sys)
Reset all forces in the system to zero.
@end deftypefun


@node System Configuration
@subsubheading System Configuration

@deftypefun void dyn_system_set_gravity (dyn_system_t *sys, double G)
Set the gravitational constant of the system.
@end deftypefun

@deftypefun void dyn_system_set_softening (dyn_system_t *sys, bool use_softening, double eps)
Enable or disable gravitational softening, with softening length @var{eps}.
@end deftypefun

@deftypefun void dyn_system_set_force_callback (dyn_system_t *sys, dyn_force_cb cb, void *userdata)
Attach a custom force computation callback.
@end deftypefun


@node Force Computation
@subsubheading Force Computation

@deftypefun int dyn_system_compute_forces (dyn_system_t *sys)
Compute all forces in the system using the callback or defaults.
@end deftypefun

@deftypefun int dyn_system_compute_pairwise_gravity (dyn_system_t *sys)
Compute gravitational forces between all particle pairs.
@end deftypefun


@node Integration
@subsubheading Integration

@deftypefun int dyn_system_step (dyn_system_t *sys, double dt, dyn_integrator_t integrator)
Perform an integration step of size @var{dt} with the selected method.
@end deftypefun

@deftypefun void dyn_system_set_time (dyn_system_t *sys, double t)
Set the simulation time.
@end deftypefun

@deftypefun double dyn_system_get_time (const dyn_system_t *sys)
Return the current simulation time.
@end deftypefun


@node Diagnostics
@subsubheading Diagnostics

@deftypefun double dyn_system_total_kinetic (const dyn_system_t *sys)
Return the total kinetic energy.
@end deftypefun

@deftypefun double dyn_system_total_potential (const dyn_system_t *sys)
Return the total potential energy.
@end deftypefun

@deftypefun double dyn_system_total_energy (const dyn_system_t *sys)
Return the total energy (kinetic + potential).
@end deftypefun

@deftypefun int dyn_system_total_momentum (const dyn_system_t *sys, gsl_vector *out_p)
Compute the total momentum into @var{out_p}.
@end deftypefun

@deftypefun int dyn_system_total_angular_momentum (const dyn_system_t *sys, gsl_vector *out_L)
Compute the total angular momentum into @var{out_L}.
@end deftypefun

@deftypefun int dyn_system_center_of_mass (const dyn_system_t *sys, gsl_vector *out_r, gsl_vector *out_v)
Compute center of mass position and velocity.
@end deftypefun

@deftypefun int dyn_system_moment_of_inertia (const dyn_system_t *sys, gsl_vector *origin, gsl_matrix *out_I)
Compute the inertia tensor relative to @var{origin}.
@end deftypefun

@deftypefun int dyn_system_check_conservation (const dyn_system_t *sys, double tol)
Check energy and momentum conservation with tolerance @var{tol}.
@end deftypefun


@node Utilities
@subsubheading Utilities

@deftypefun void dyn_system_print (const dyn_system_t *sys, FILE *f)
Print the system state.
@end deftypefun

@deftypefun void dyn_particle_print (const dyn_particle_t *p, FILE *f)
Print the state of a single particle.
@end deftypefun

@deftypefun int dyn_system_save (const dyn_system_t *sys, const char *filename)
Save the system state to file.
@end deftypefun

@deftypefun {dyn_system_t *} dyn_system_load (const char *filename)
Load a system state from file.
@end deftypefun

@deftypefun {dyn_system_t *} dyn_system_clone (const dyn_system_t *src)
Deep copy of a system.
@end deftypefun

@deftypefun int dyn_system_add_particle (dyn_system_t *sys, const dyn_particle_t *p)
Add a particle to the system.
@end deftypefun

@deftypefun int dyn_system_remove_particle (dyn_system_t *sys, size_t idx)
Remove a particle by index.
@end deftypefun

@deftypefun {dyn_particle_t *} dyn_system_find_particle (dyn_system_t *sys, int id)
Find a particle by ID.
@end deftypefun

@deftypefun int dyn_system_apply_constraints (dyn_system_t *sys)
Apply constraints if present.
@end deftypefun


@node fluids
@subsubsection fluids.h

The file @code{fluids.h} defines the API for classical fluid mechanics in HOLOS.
It provides data types and functions for simulating incompressible and
compressible flows, solving Navier–Stokes equations, and computing
diagnostic quantities such as Reynolds and Mach numbers.  
All functions use GNU Scientific Library (GSL) vectors and matrices.

@menu
* Fluid Types::
* Core Equations::
* Diagnostic Functions::
* Utilities::
* System Management::
@end menu


@node Fluid Types
@subsubheading Types

@deftp {Data type} fluid_element
Represents a single fluid element with density, pressure, velocity vector,
temperature, viscosity, thermal conductivity, internal energy, and optional metadata.
@end deftp

@deftp {Data type} fluid_system
Represents a collection of fluid elements with simulation time,
volume, boundaries, and optional user data.
@end deftp


@node Core Equations
@subsubheading Core Fluid Equations

@deftypefun int fluid_continuity_equation (gsl_vector *rho_time_deriv, const gsl_vector *rho, const gsl_matrix *v)
Compute the continuity equation
@tex
$\partial \rho/\partial t + \nabla \cdot (\rho v) = 0$.
@end tex
@end deftypefun

@deftypefun int fluid_navier_stokes (gsl_matrix *v_time_deriv, const gsl_matrix *v, const gsl_vector *p, const gsl_vector *rho, double mu, const gsl_matrix *f)
Compute the incompressible Navier–Stokes equations:
@tex
$\rho(\partial v/\partial t + (v\cdot\nabla)v) = -\nabla p + \mu\nabla^2 v + f$.
@end tex
@end deftypefun


@node Diagnostic Functions
@subsubheading Diagnostics and Dimensionless Numbers

@deftypefun double fluid_bernoulli (double rho, double v, double g, double h)
Compute Bernoulli’s equation for incompressible, inviscid flow.
@end deftypefun

@deftypefun double fluid_reynolds_number (double rho, double v, double L, double mu)
Compute the Reynolds number: Re = (ρ v L) / μ.
@end deftypefun

@deftypefun double fluid_mach_number (double v, double c)
Compute the Mach number: Ma = v / c.
@end deftypefun

@deftypefun double fluid_speed_of_sound (double gamma, double p, double rho)
Compute the speed of sound: c = sqrt(γ p / ρ).
@end deftypefun

@deftypefun int fluid_vorticity (gsl_matrix *vorticity, const gsl_matrix *v)
Compute the vorticity field from the velocity field.
@end deftypefun

@deftypefun int fluid_divergence (gsl_vector *div, const gsl_matrix *v)
Compute the divergence of the velocity field.
@end deftypefun


@node Utilities
@subsubheading Element Utilities

@deftypefun {fluid_element *} fluid_element_alloc (size_t dim)
Allocate a new fluid element with velocity vector dimension @var{dim}.
@end deftypefun

@deftypefun void fluid_element_free (fluid_element *elem)
Free a fluid element and its resources.
@end deftypefun

@deftypefun void fluid_element_print (const fluid_element *elem, FILE *f)
Print the properties of a fluid element to file or stdout.
@end deftypefun


@node System Management
@subsubheading System Utilities

@deftypefun {fluid_system *} fluid_system_alloc (size_t n, size_t dim)
Initialize a system with @var{n} fluid elements and velocity dimension @var{dim}.
@end deftypefun

@deftypefun void fluid_system_free (fluid_system *sys)
Free a system and all its elements.
@end deftypefun

@deftypefun void fluid_system_print (const fluid_system *sys, FILE *f)
Print system properties to file or stdout.
@end deftypefun

@deftypefun {fluid_system *} fluid_system_clone (const fluid_system *src)
Create a deep copy of a fluid system.
@end deftypefun

@deftypefun int fluid_system_add_element (fluid_system *sys, const fluid_element *elem)
Add a new fluid element to the system, returning its index.
@end deftypefun

@deftypefun int fluid_system_remove_element (fluid_system *sys, size_t idx)
Remove a fluid element by index.
@end deftypefun

@deftypefun {fluid_element *} fluid_system_find_element (fluid_system *sys, const char *tag)
Find an element by its tag string.
@end deftypefun

@deftypefun int fluid_system_apply_boundaries (fluid_system *sys)
Apply boundary conditions if present.
@end deftypefun

@node kinematics
@subsubsection kinematics.h

The file @code{kinematics.h} defines the API for classical Newtonian kinematics
in HOLOS.  
It provides functions and data structures for positions, velocities,
accelerations, trajectories, and basic integration.  
All functions use GNU Scientific Library (GSL) vectors and matrices.



@node oscillations
@subsubsection oscillations.h
Covers simple harmonic motion, damped oscillations, and driven oscillatory systems.
@node statics
@subsubsection statics.h
Focuses on forces in static systems, including beams, trusses, and other structures.

@node Analytical Mechanics
@subsection Analytical Mechanics
@file{include/core/phys/mech/analytical/}

Focuses on Lagrangian and Hamiltonian formulations:
@itemize @bullet
@item @file{lagrange.h} -- Lagrangian mechanics
@item @file{hamilton.h} -- Hamiltonian mechanics
@end itemize

@node hamilton
@subsubsection hamilton.h

@node lagrange
@subsubsection lagrange.h

@node Continuum Mechanics
@subsection Continuum Mechanics
@file{include/core/phys/mech/continuum/}

Models continuous media:
@itemize @bullet
@item @file{elasticity.h} -- Elasticity and deformation
@item @file{fluid_dynamics.h} -- Advanced fluid dynamics
@end itemize

@node Quantum Mechanics
@subsection Quantum Mechanics
@file{include/core/phys/mech/quantum/}

Quantum systems and wave mechanics:
@itemize @bullet
@item @file{particle_in_box.h} -- Particle in a box
@item @file{quantum_harmonic_oscillator.h} -- Quantum oscillators
@item @file{schrodinger.h} -- Schrödinger equation
@end itemize

@node Relativistic Mechanics
@subsection Relativistic Mechanics
@file{include/core/phys/mech/relativistic/}

Special and general relativity:
@itemize @bullet
@item @file{relativistic_mech.h} -- Relativistic dynamics
@end itemize

@node Astrophysics
@subsection Astrophysics
@file{include/core/phys/astro/}

Celestial and orbital mechanics:
@itemize @bullet
@item @file{celestial_mechanics.h} -- Celestial mechanics
@item @file{orbital_dynamics.h} -- Orbital dynamics
@end itemize

@node Electromagnetism
@subsection Electromagnetism
@file{include/core/phys/em/}

Electromagnetic theory and applications:
@itemize @bullet
@item @file{lorentz_forces.h} -- Lorentz force calculations
@item @file{maxwell.c} -- Maxwell's equations
@item @file{wave_equations.c} -- Electromagnetic waves
@end itemize

@node Fields
@subsection Fields
@file{include/core/phys/fields/}

Field theory and quantum field theory:
@itemize @bullet
@item @file{qft.h} -- Quantum field theory basics
@end itemize

@node Nuclear Physics
@subsection Nuclear Physics
@file{include/core/phys/nuclear/}

Nuclear structure and reactions:
@itemize @bullet
@item @file{fission_fusion.h} -- Fission and fusion processes
@item @file{nuclear_decay.h} -- Radioactive decay
@item @file{nuclear_forces.h} -- Nuclear forces
@end itemize

@node Solid State Physics
@subsection Solid State Physics
@file{include/core/phys/ss/}

Crystalline and condensed matter physics:
@itemize @bullet
@item @file{band_structure.h} -- Band structure
@item @file{crystal_lattice.h} -- Crystal lattices
@item @file{phonons.h} -- Phonons and lattice vibrations
@end itemize

@node Thermodynamics
@subsection Thermodynamics
@file{include/core/phys/thermo/}

Thermodynamic systems and heat transfer:
@itemize @bullet
@item @file{entropy.h} -- Entropy and statistical mechanics
@item @file{heat_transfer.h} -- Heat transfer
@item @file{thermodynamics.h} -- Thermodynamic laws and cycles
@end itemize

Each submodule header provides data structures and function prototypes for its domain. See the @file{include/core/phys/} directory for details and example usage.

@node AI
@section AI
The AI module implements neural network models for scientific and engineering applications. Available models:

@itemize @bullet
@item @b{Multilayer Perceptron (MLP):} @file{include/core/ai/mlp.h}
@item @b{Convolutional Neural Network (CNN):} @file{include/core/ai/cnn.h}
@item @b{Recurrent Neural Network (RNN):} @file{include/core/ai/rnn.h}
@item @b{Generative Adversarial Network (GAN):} @file{include/core/ai/gan.h}
@item @b{Transformer:} @file{include/core/ai/transformer.h}
@end itemize

Each header defines the data structures and function signatures for its model. Example usage:

@example
#include <core/ai/mlp.h>
// ... use MLP functions ...
@end example

@node P2P
@section P2P
The P2P module enables peer-to-peer scientific collaboration using GNUnet. It provides distributed data sharing and computation features for collaborative research.

@itemize @bullet
@item @b{Headers:} @file{include/core/p2p/p2p.h}
@item @b{Source:} @file{src/p2p/p2p.c}
@end itemize

GNUnet is optional but recommended for distributed workflows. See the README for setup instructions.

@node CLI
@section CLI
The CLI module provides a command-line interface for running simulations, managing models, and accessing HOLOS features.

@itemize @bullet
@item @b{Header:} @file{include/cli/cli.h}
@item @b{Source:} @file{src/cli/cli.c}
@end itemize

Example usage:

@example
$ holos --help
@end example

Each module is documented in its own header and source files. See the @file{include/} and @file{src/} directories for details.

@node Development
@chapter Development
HOLOS follows the GNU coding standards. The build system uses GNU Autotools (@file{configure.ac}, @file{Makefile.am}).

@itemize @bullet
@item Source code: @file{src/}
@item Headers: @file{include/}
@item Documentation: @file{doc/}
@item Tests: @file{tests/}
@end itemize

Contributions are welcome. Please submit patches or pull requests via the project repository.

@node License
@chapter License
HOLOS is licensed under the GNU General Public License (GPL) version 3 or later. See the file @file{LICENSE} for details.

@bye